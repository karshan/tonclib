<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libtonc: Bit(field) macros</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libtonc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Bit(field) macros<div class="ingroups"><a class="el" href="group__grpCore.htm">Core</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad6e259844fb7a1aeefb8895a13312946"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__grpTypeAttr.htm#ga2eb6f9e0395b47b8d5e3eeae4fe0c116">INLINE</a> u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#gad6e259844fb7a1aeefb8895a13312946">bf_get</a> (u32 y, uint shift, uint len)</td></tr>
<tr class="memdesc:gad6e259844fb7a1aeefb8895a13312946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <em>len</em> long bitfield from <em>y</em>, starting at <em>shift</em>.  <a href="#gad6e259844fb7a1aeefb8895a13312946">More...</a><br /></td></tr>
<tr class="separator:gad6e259844fb7a1aeefb8895a13312946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85036411a33d75a18555647820b32b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__grpTypeAttr.htm#ga2eb6f9e0395b47b8d5e3eeae4fe0c116">INLINE</a> u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga85036411a33d75a18555647820b32b67">bf_merge</a> (u32 y, u32 x, uint shift, uint len)</td></tr>
<tr class="memdesc:ga85036411a33d75a18555647820b32b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge <em>x</em> into an <em>len</em> long bitfield from <em>y</em>, starting at <em>shift</em>.  <a href="#ga85036411a33d75a18555647820b32b67">More...</a><br /></td></tr>
<tr class="separator:ga85036411a33d75a18555647820b32b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga040c06a15e0eb895290eb638eab5cbe7"><td class="memItemLeft" align="right" valign="top"><a id="ga040c06a15e0eb895290eb638eab5cbe7"></a>
<a class="el" href="group__grpTypeAttr.htm#ga2eb6f9e0395b47b8d5e3eeae4fe0c116">INLINE</a> u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga040c06a15e0eb895290eb638eab5cbe7">bf_clamp</a> (int x, uint len)</td></tr>
<tr class="memdesc:ga040c06a15e0eb895290eb638eab5cbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp <em>to</em> within the range allowed by <em>len</em> bits. <br /></td></tr>
<tr class="separator:ga040c06a15e0eb895290eb638eab5cbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb302a4e8a431b08b8b4a280886ebb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__grpTypeAttr.htm#ga2eb6f9e0395b47b8d5e3eeae4fe0c116">INLINE</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga5cb302a4e8a431b08b8b4a280886ebb3">bit_tribool</a> (u32 flags, uint plus, uint minus)</td></tr>
<tr class="memdesc:ga5cb302a4e8a431b08b8b4a280886ebb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives a tribool (-1, 0, or +1) depending on the state of some bits.  <a href="#ga5cb302a4e8a431b08b8b4a280886ebb3">More...</a><br /></td></tr>
<tr class="separator:ga5cb302a4e8a431b08b8b4a280886ebb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e0b242dbe5e7c56cb43177b211a022f"><td class="memItemLeft" align="right" valign="top"><a id="ga1e0b242dbe5e7c56cb43177b211a022f"></a>
<a class="el" href="group__grpTypeAttr.htm#ga2eb6f9e0395b47b8d5e3eeae4fe0c116">INLINE</a> u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga1e0b242dbe5e7c56cb43177b211a022f">ROR</a> (u32 x, uint ror)</td></tr>
<tr class="memdesc:ga1e0b242dbe5e7c56cb43177b211a022f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate bits right. Yes, this does lead to a ror instruction. <br /></td></tr>
<tr class="separator:ga1e0b242dbe5e7c56cb43177b211a022f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Simple bit macros</h2></td></tr>
<tr class="memitem:ga3a8ea58898cb58fc96013383d39f482c"><td class="memItemLeft" align="right" valign="top"><a id="ga3a8ea58898cb58fc96013383d39f482c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(n)&#160;&#160;&#160;( 1&lt;&lt;(n) )</td></tr>
<tr class="memdesc:ga3a8ea58898cb58fc96013383d39f482c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create value with bit <em>n</em> set. <br /></td></tr>
<tr class="separator:ga3a8ea58898cb58fc96013383d39f482c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f405ad0f48fac0de71a4fdad6302d8d"><td class="memItemLeft" align="right" valign="top"><a id="ga9f405ad0f48fac0de71a4fdad6302d8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga9f405ad0f48fac0de71a4fdad6302d8d">BIT_SHIFT</a>(a,  n)&#160;&#160;&#160;( (a)&lt;&lt;(n) )</td></tr>
<tr class="memdesc:ga9f405ad0f48fac0de71a4fdad6302d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift <em>a</em> by <em>n</em>. <br /></td></tr>
<tr class="separator:ga9f405ad0f48fac0de71a4fdad6302d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga554ced246cf0ab94852054a9bfa5f45b"><td class="memItemLeft" align="right" valign="top"><a id="ga554ced246cf0ab94852054a9bfa5f45b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga554ced246cf0ab94852054a9bfa5f45b">BIT_MASK</a>(len)&#160;&#160;&#160;( <a class="el" href="group__grpCoreBit.htm#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(len)-1 )</td></tr>
<tr class="memdesc:ga554ced246cf0ab94852054a9bfa5f45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bitmask <em>len</em> bits long. <br /></td></tr>
<tr class="separator:ga554ced246cf0ab94852054a9bfa5f45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c6ae74f0307ff20ed00182feb73dd02"><td class="memItemLeft" align="right" valign="top"><a id="ga8c6ae74f0307ff20ed00182feb73dd02"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga8c6ae74f0307ff20ed00182feb73dd02">BIT_SET</a>(y,  flag)&#160;&#160;&#160;( y |=  (flag) )</td></tr>
<tr class="memdesc:ga8c6ae74f0307ff20ed00182feb73dd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <em>flag</em> bits in <em>word</em>. <br /></td></tr>
<tr class="separator:ga8c6ae74f0307ff20ed00182feb73dd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae76053decf05e22767fa234960673f18"><td class="memItemLeft" align="right" valign="top"><a id="gae76053decf05e22767fa234960673f18"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#gae76053decf05e22767fa234960673f18">BIT_CLEAR</a>(y,  flag)&#160;&#160;&#160;( y &amp;= ~(flag) )</td></tr>
<tr class="memdesc:gae76053decf05e22767fa234960673f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the <em>flag</em> bits in <em>word</em>. <br /></td></tr>
<tr class="separator:gae76053decf05e22767fa234960673f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ad99435edf7a76942a5bf92ef3e809"><td class="memItemLeft" align="right" valign="top"><a id="ga61ad99435edf7a76942a5bf92ef3e809"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga61ad99435edf7a76942a5bf92ef3e809">BIT_FLIP</a>(y,  flag)&#160;&#160;&#160;( y ^=  (flag) )</td></tr>
<tr class="memdesc:ga61ad99435edf7a76942a5bf92ef3e809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the <em>flag</em> bits in <em>word</em>. <br /></td></tr>
<tr class="separator:ga61ad99435edf7a76942a5bf92ef3e809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4267aa64d870ab4d9329570281dbcc4c"><td class="memItemLeft" align="right" valign="top"><a id="ga4267aa64d870ab4d9329570281dbcc4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga4267aa64d870ab4d9329570281dbcc4c">BIT_EQ</a>(y,  flag)&#160;&#160;&#160;( ((y)&amp;(flag)) == (flag) )</td></tr>
<tr class="memdesc:ga4267aa64d870ab4d9329570281dbcc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether all the <em>flag</em> bits in <em>word</em> are set. <br /></td></tr>
<tr class="separator:ga4267aa64d870ab4d9329570281dbcc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b35f56c6501bccb948b3576fadd4e5"><td class="memItemLeft" align="right" valign="top"><a id="gaa9b35f56c6501bccb948b3576fadd4e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#gaa9b35f56c6501bccb948b3576fadd4e5">BF_MASK</a>(shift,  len)&#160;&#160;&#160;( <a class="el" href="group__grpCoreBit.htm#ga554ced246cf0ab94852054a9bfa5f45b">BIT_MASK</a>(len)&lt;&lt;(shift) )</td></tr>
<tr class="memdesc:gaa9b35f56c6501bccb948b3576fadd4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bitmask of length <em>len</em> starting at bit <em>shift</em>. <br /></td></tr>
<tr class="separator:gaa9b35f56c6501bccb948b3576fadd4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ce0c9bb285c8fd508dfb6480ea9b88"><td class="memItemLeft" align="right" valign="top"><a id="ga26ce0c9bb285c8fd508dfb6480ea9b88"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga26ce0c9bb285c8fd508dfb6480ea9b88">_BF_GET</a>(y,  shift,  len)&#160;&#160;&#160;( ((y)&gt;&gt;(shift))&amp;<a class="el" href="group__grpCoreBit.htm#ga554ced246cf0ab94852054a9bfa5f45b">BIT_MASK</a>(len) )</td></tr>
<tr class="memdesc:ga26ce0c9bb285c8fd508dfb6480ea9b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a bitfield mask of length <em>starting</em> at bit <em>shift</em> from <em>y</em>. <br /></td></tr>
<tr class="separator:ga26ce0c9bb285c8fd508dfb6480ea9b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2b19ad760c2dc2c13218c238f591a9a"><td class="memItemLeft" align="right" valign="top"><a id="gab2b19ad760c2dc2c13218c238f591a9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#gab2b19ad760c2dc2c13218c238f591a9a">_BF_PREP</a>(x,  shift,  len)&#160;&#160;&#160;( ((x)&amp;<a class="el" href="group__grpCoreBit.htm#ga554ced246cf0ab94852054a9bfa5f45b">BIT_MASK</a>(len))&lt;&lt;(shift) )</td></tr>
<tr class="memdesc:gab2b19ad760c2dc2c13218c238f591a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a bitmask for insertion or combining. <br /></td></tr>
<tr class="separator:gab2b19ad760c2dc2c13218c238f591a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d92758a47a3738aac0c7886c3bb5e3"><td class="memItemLeft" align="right" valign="top"><a id="gaf7d92758a47a3738aac0c7886c3bb5e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#gaf7d92758a47a3738aac0c7886c3bb5e3">_BF_SET</a>(y,  x,  shift,  len)&#160;&#160;&#160;( y= ((y) &amp;~ <a class="el" href="group__grpCoreBit.htm#gaa9b35f56c6501bccb948b3576fadd4e5">BF_MASK</a>(shift, len)) | <a class="el" href="group__grpCoreBit.htm#gab2b19ad760c2dc2c13218c238f591a9a">_BF_PREP</a>(x, shift, len) )</td></tr>
<tr class="memdesc:gaf7d92758a47a3738aac0c7886c3bb5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new bitfield value <em>x</em> into <em>y</em>. <br /></td></tr>
<tr class="separator:gaf7d92758a47a3738aac0c7886c3bb5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
some EVIL bit-field operations, &gt;:)</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp66d394fef43412d547d622061fd50f14"></a>These allow you to mimic bitfields with macros. Most of the bitfields in the registers have <em>foo</em>_SHIFT and <em>foo</em>_SHIFT macros indicating the mask and shift values of the bitfield named <em>foo</em> in a variable. These macros let you prepare, get and set the bitfields. </p>
</td></tr>
<tr class="memitem:gaab4904c3bcb2a4b3d80c64d9f9595f95"><td class="memItemLeft" align="right" valign="top"><a id="gaab4904c3bcb2a4b3d80c64d9f9595f95"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#gaab4904c3bcb2a4b3d80c64d9f9595f95">BFN_PREP</a>(x,  name)&#160;&#160;&#160;( ((x)&lt;&lt;name##_SHIFT) &amp; name##_MASK )</td></tr>
<tr class="memdesc:gaab4904c3bcb2a4b3d80c64d9f9595f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a named bit-field for for insterion or combination. <br /></td></tr>
<tr class="separator:gaab4904c3bcb2a4b3d80c64d9f9595f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9c05f7c87a52e2321a3888957719e67"><td class="memItemLeft" align="right" valign="top"><a id="gaf9c05f7c87a52e2321a3888957719e67"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#gaf9c05f7c87a52e2321a3888957719e67">BFN_GET</a>(y,  name)&#160;&#160;&#160;( ((y) &amp; name##_MASK)&gt;&gt;name##_SHIFT )</td></tr>
<tr class="memdesc:gaf9c05f7c87a52e2321a3888957719e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a named bitfield from <em>y</em>. Equivalent to (var=) y.name. <br /></td></tr>
<tr class="separator:gaf9c05f7c87a52e2321a3888957719e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932fd2ab5498eaa9999ba05a0c06e971"><td class="memItemLeft" align="right" valign="top"><a id="ga932fd2ab5498eaa9999ba05a0c06e971"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga932fd2ab5498eaa9999ba05a0c06e971">BFN_SET</a>(y,  x,  name)&#160;&#160;&#160;(y = ((y)&amp;~name##_MASK) | <a class="el" href="group__grpCoreBit.htm#gaab4904c3bcb2a4b3d80c64d9f9595f95">BFN_PREP</a>(x,name) )</td></tr>
<tr class="memdesc:ga932fd2ab5498eaa9999ba05a0c06e971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a named bitfield in <em>y</em> to <em>x</em>. Equivalent to y.name= x. <br /></td></tr>
<tr class="separator:ga932fd2ab5498eaa9999ba05a0c06e971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1187bcb559c3387fce1fbc747828ddc"><td class="memItemLeft" align="right" valign="top"><a id="gaa1187bcb559c3387fce1fbc747828ddc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#gaa1187bcb559c3387fce1fbc747828ddc">BFN_CMP</a>(y,  x,  name)&#160;&#160;&#160;( ((y)&amp;name##_MASK) == (x) )</td></tr>
<tr class="memdesc:gaa1187bcb559c3387fce1fbc747828ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a named bitfield to named literal <em>x</em>. <br /></td></tr>
<tr class="separator:gaa1187bcb559c3387fce1fbc747828ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dc82662aea29a805b7d76b54e8af2ec"><td class="memItemLeft" align="right" valign="top"><a id="ga4dc82662aea29a805b7d76b54e8af2ec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga4dc82662aea29a805b7d76b54e8af2ec">BFN_PREP2</a>(x,  name)&#160;&#160;&#160;( (x) &amp; name##_MASK )</td></tr>
<tr class="memdesc:ga4dc82662aea29a805b7d76b54e8af2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Massage <em>x</em> for use in bitfield <em>name</em> with pre-shifted <em>x</em>. <br /></td></tr>
<tr class="separator:ga4dc82662aea29a805b7d76b54e8af2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5eac618bcb48f787c94cc2ebbefbc61"><td class="memItemLeft" align="right" valign="top"><a id="gae5eac618bcb48f787c94cc2ebbefbc61"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#gae5eac618bcb48f787c94cc2ebbefbc61">BFN_GET2</a>(y,  name)&#160;&#160;&#160;( (y) &amp; name##_MASK )</td></tr>
<tr class="memdesc:gae5eac618bcb48f787c94cc2ebbefbc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of bitfield <em>name</em> from <em>y</em>, but don't down-shift. <br /></td></tr>
<tr class="separator:gae5eac618bcb48f787c94cc2ebbefbc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04c777d63f2aadbc80cc9c528a3a36a5"><td class="memItemLeft" align="right" valign="top"><a id="ga04c777d63f2aadbc80cc9c528a3a36a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grpCoreBit.htm#ga04c777d63f2aadbc80cc9c528a3a36a5">BFN_SET2</a>(y,  x,  name)&#160;&#160;&#160;( y = ((y)&amp;~name##_MASK) | <a class="el" href="group__grpCoreBit.htm#ga4dc82662aea29a805b7d76b54e8af2ec">BFN_PREP2</a>(x,name) )</td></tr>
<tr class="memdesc:ga04c777d63f2aadbc80cc9c528a3a36a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bitfield <em>name</em> from <em>y</em> to <em>x</em> with pre-shifted <em>x</em>. <br /></td></tr>
<tr class="separator:ga04c777d63f2aadbc80cc9c528a3a36a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad6e259844fb7a1aeefb8895a13312946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6e259844fb7a1aeefb8895a13312946">&#9670;&nbsp;</a></span>bf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__grpTypeAttr.htm#ga2eb6f9e0395b47b8d5e3eeae4fe0c116">INLINE</a> u32 bf_get </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <em>len</em> long bitfield from <em>y</em>, starting at <em>shift</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Value containing bitfield. </td></tr>
    <tr><td class="paramname">shift</td><td>Bitfield Start; </td></tr>
    <tr><td class="paramname">len</td><td>Length of bitfield. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitfield between bits <em>shift</em> and <em>shift</em> + <em>length</em>. </dd></dl>

</div>
</div>
<a id="ga85036411a33d75a18555647820b32b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85036411a33d75a18555647820b32b67">&#9670;&nbsp;</a></span>bf_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__grpTypeAttr.htm#ga2eb6f9e0395b47b8d5e3eeae4fe0c116">INLINE</a> u32 bf_merge </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge <em>x</em> into an <em>len</em> long bitfield from <em>y</em>, starting at <em>shift</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Value containing bitfield. </td></tr>
    <tr><td class="paramname">x</td><td>Value to merge (will be masked to fit). </td></tr>
    <tr><td class="paramname">shift</td><td>Bitfield Start; </td></tr>
    <tr><td class="paramname">len</td><td>Length of bitfield. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of merger: (y&amp;~M) | (x&lt;&lt;s &amp; M) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does <em>not</em> write the result back into <em>y</em> (Because pure C does't have references, that's why) </dd></dl>

</div>
</div>
<a id="ga5cb302a4e8a431b08b8b4a280886ebb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cb302a4e8a431b08b8b4a280886ebb3">&#9670;&nbsp;</a></span>bit_tribool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__grpTypeAttr.htm#ga2eb6f9e0395b47b8d5e3eeae4fe0c116">INLINE</a> int bit_tribool </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>plus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>minus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives a tribool (-1, 0, or +1) depending on the state of some bits. </p>
<p>Looks at the <em>plus</em> and <em>minus</em> bits of <em>flags</em>, and subtracts their status to give a +1, -1 or 0 result. Useful for direction flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Value with bit-flags. </td></tr>
    <tr><td class="paramname">plus</td><td>Bit number for positive result. </td></tr>
    <tr><td class="paramname">minus</td><td>Bit number for negative result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>+1</b> if <em>plus</em> bit is set but <em>minus</em> bit isn't<br />
 <b>-1</b> if <em>minus</em> bit is set and <em>plus</em> bit isn't<br />
 <b>0</b> if neither or both are set. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__grpInput.htm#ga6ceca0b0d0f0f2c7053e9b9ba4e4b350">key_tri_fire()</a>, <a class="el" href="group__grpInput.htm#ga211041ef4b51b5ddd25da688bf5e0973">key_tri_horz()</a>, <a class="el" href="group__grpInput.htm#ga3b1e6aa939108af1d48e09b5ef014e53">key_tri_shoulder()</a>, and <a class="el" href="group__grpInput.htm#ga5b7c4434a603b8e9dffe97d1d016e600">key_tri_vert()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
